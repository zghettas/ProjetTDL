----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh gauche      : Expression for SuiteCondition, SuiteTerme, SuiteFacteur;

inh factory     : BlockFactory for Bloc, Instruction, SuiteConditionnelle, Instructions, 
                  Expression, Expressions, SuiteExpressions, Condition, SuiteCondition, 
                  Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, TypeAtomique, Affectable, 
                  SuiteAffectable, Acces, SuiteNouveau, HeritageInterface, Interface, Interfaces, Programme, Classes, Principale, SuiteHeritageInterface, ElementInterface, Signature, Classe, HeritageClasse, ImplantationInterface, ElementsInterface, MethodePrincipale, Genericite ;  

inh tds         : SymbolTable for Bloc, Instructions, Instruction, Expression, Expressions,
                  SuiteExpressions, Facteur, SuiteConditionnelle, Terme, SuiteTerme, SuiteFacteur,
                  Condition, SuiteCondition, TypeAtomique, Valeur, Affectable, SuiteAffectable, SuiteNouveau, Acces, Interfaces, Classes, Principale, HeritageInterface, SuiteHeritageInterface, ElementsInterface, Classe, HeritageClasse, Element, InstanceGenericite, ImplantationInterface, Type, ElementInterface, Signature, Parametres, MethodePrincipale;

inh tdsSignaturesInterface : 	SymbolTableSignature for Interfaces, Interface, Signature, ElementInterface, ElementsInterface;

inh tdsConstantesInterface :  	SymbolTable for Interfaces, Interface, ElementInterface, ElementsInterface;

inh tdsNomsInterface	    :	SymbolTable for Interfaces, HeritageInterface, SuiteHeritageInterface, ImplantationInterface, InstanceGenericite, Classe, Genericite, HeritageClasse, Interface, ElementsInterface, Classes, Programme, Principale;

inh elementsClasse	    : 	SymbolTable for Classes, Principale;

inh type        : Type for SuiteTypeAtomique ;

inh support     : Expression for Acces ;

inh support     : Assignable for SuiteAffectable ;

inh type        : Type for SuiteNouveau ;

syn ast         : Block for Programme, Bloc, SuiteConditionnelle ;

syn ast         : Expression for Expression, Condition, SuiteCondition, Terme, SuiteTerme, 
                  Facteur, SuiteFacteur, Acces, SuiteNouveau ;

syn ast         : Type for TypeAtomique ;

syn ast         : Value for Valeur ;

syn ast         : ArrayList<Instruction> for Instructions ;

syn ast         : Instruction for Instruction ;

syn ast         : Assignable for Affectable, SuiteAffectable ;

syn bin_op      : BinaryOperator for Additif, Multiplicatif, Comparatif ;

syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions ;

syn interfaces  : LinkedList<InterfaceDeclaration> for Interfaces ;

syn interface   : InterfaceDeclaration for Interface ;

syn ast 	: Interface for HeritageInterface;

syn ast		: LinkedList<Interface> for SuiteHeritageInterface;

syn ast 	: Instance for InstanceGenericite;

syn ast 	: Element for ElementInterface;

syn elements 	: LinkedList<Element> for ElementsInterface;

syn ast 	: LinkedList<Element> for ElementsClasse;

syn ast 	: Implantation for ImplantationInterface;

syn ast		: Type for Type;

syn ast		: Methode for MethodePrincipale;

syn classes	: LinkedList<Classe> for Classes;

syn ast		: Classe for Classe, Principale;

syn ast		: Generic for Genericite, ParametresGenericite;

syn ast 	: Signature for Signature;

syn ast 	: LinkedList<Parametre> for Parametres;

syn ast 	: Heritage for HeritageClasse;





space  separateur             is    "[\n\r\t ]+";
space  commentaire            is    "\/\/.*\n";
sugar  accolade_ouvrante      is    "\{";  
sugar  accolade_fermante      is    "\}";  
sugar  crochet_ouvrant        is    "\[";  
sugar  crochet_fermant        is    "\]";  
sugar  parenthese_ouvrante    is    "\(";
sugar  parenthese_fermante    is    "\)";
sugar  inferieur              is    "\<";  
sugar  superieur              is    "\>";  
sugar  inferieur_egal         is    "\<=";  
sugar  superieur_egal         is    "\>=";  
sugar  point                  is    "\.";  
sugar  point_virgule          is    ";";  
sugar  virgule                is    ",";
sugar  affectation            is    "=";
sugar  egalite                is    "==";  
sugar  different              is    "\!=";  
sugar  addition               is    "\+";
sugar  soustraction           is    "\-";
sugar  ou                     is    "\|\|";  
sugar  multiplication         is    "\*";
sugar  division               is    "/";
sugar  modulo                 is    "%";
sugar  adresse                is    "&";  
sugar  negation               is    "\!";  
sugar  et                     is    "&&";  
sugar  vrai                   is    "true";
sugar  faux                   is    "false";
sugar  si                     is    "if";
sugar  sinon                  is    "else";
sugar  afficher               is    "print";  
sugar  nouveau                is    "new";  
sugar  tant_que               is    "while";  
sugar  retour                 is    "return";  
sugar  type_int               is    "int";
sugar  type_bool              is    "boolean";  
sugar  type_char              is    "char";        
sugar  type_String            is    "String";        
sugar  vide                   is    "void";     
sugar  nul                    is    "null";     
sugar  choix                  is    "\?";         
sugar  deux_points            is    ":";          
sugar  interface              is    "interface";     
sugar  classe                 is    "class";      
sugar  extension              is    "extends";      
sugar  implantation           is    "implements";      
sugar  public                 is    "public";    
sugar  protege                is    "protected";    
sugar  prive                  is    "private";     
sugar  statique               is    "static";       
sugar  final                  is    "final";       
sugar  principale             is    "main";  
term   chaine                 is    "\"([^\"]|\\\")*\"";  
term   caractere              is    "\'[^\']\'";  
term   entier                 is    "[0-9]+";
term   identificateur         is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type    is    "[A-Z][a-zA-Z0-9_]*"; 


Programme -> #tds Interfaces Classes Principale #ast;
#tds {
local
	st : SymbolTable;
	st2 : SymbolTable;
	st2_1 : SymbolTableSignatures;
	st2_2 : SymbolTable;
	st3 : SymbolTable;
	st3_1 : SymbolTable;
	st3_2 : SymbolTable;
	st4 : SymbolTable;
	st4_1 : SymbolTable;
	st4_2 : SymbolTable;
do
	st := new SymbolTable();
	Interfaces^tds := st;
	Classes^tds := st;
	Principale^tds := st;
	st2 := new SymbolTable();
	Interfaces^tdsNomsInterface := st2;
	st2_1 := new SymbolTableSignature();
	Interfaces^tdsSignaturesInterface := st2_1;
	st2_2 := new SymbolTable();
	Interfaces^tdsConstantesInterface := st2_2;
	st3 := new SymbolTable();
	Classes^elementsClasse := st3;
	st4 := new SymbolTable();
	Principale^elementsClasse := st4;
	
end
}
#ast {
local
	bfi : BlockFactoryImpl;
do
	bfi := new BlockFactoryImpl();
	Programme^ast := bfi.createProgramme(Interfaces^interfaces, Classes^classes, Principale^ast);
end
}


Interfaces -> #inh Interface #inh1 Interfaces #interfaces;
#interfaces {
local
	interfaces : LinkedList<Interfaces>;
do
    interfaces := Interfaces1^interfaces;
    interfaces.addFirst(Interface^interface);
    Interfaces^interfaces := interfaces;
end
}
#inh {
do
	Interface^tdsConstantesInterface := new SymbolTable();
	Interface^tdsSignaturesInterface := new SymbolTable();
end
}
#inh1 {
local
	bfi : BlockFactoryImpl;
do
	bfi := new BlockFactoryImpl();
	if Interfaces^tdsNomsInterface.contains(Interface^interface.getNom()) then
		error(INTERFACE_ALREADY_DECLARED);
	else
		Interfaces1^tdsNomsInterface.register(bfi.createInterfaceDeclaration(Interface^interface));
	end
end
}

Interfaces -> #interfaces;
#interfaces {
do
   Interfaces^interfaces := new LinkedList<Interface>();
end
}

Interface -> interface identificateur_type Genericite #inh HeritageInterface accolade_ouvrante ElementsInterface accolade_fermante #ast;
#ast {
local
   	i : Interface;
do
	i := Interface^factory.createInterface(identificateur_type^txt, Genericite^ast, HeritageInterface^ast, ElementsInterface^elements);
   	Interface^interface:= i;
end
}

#inh{
do
	HeritageInterface^tds := new SymbolTable();
	HeritageInterface^tdsNomsInterface := new SymbolTable();
	ElementsInterface^tds := new SymnolTable();
end
} 	

HeritageInterface -> extension identificateur_type #inh InstanceGenericite SuiteHeritageInterface #ast;
#inh{
 local
    l : List<String>;
 do
 	if (HeritageInterface^tdsNomsInterface.contains(identificateur_type^txt)) then
 		l := new LinkedList<String>();
 		l.add(identificateur_type^txt);
 	else
 		error(HERITAGE_INTERFACE_INEXISTANTE, identificateur_type^txt);
 	end	
 end
}
#ast{
local
   od : Optional<Declaration>;
   d : Declaration;
do
	od := HeritageInterface^tdsNomsInterface.get(identificateur_type^txt);
	d := od.get();
	match d with Interface then
		SuiteHeritageInterface^ast.addFirst(d);
    end
	HeritageInterface^ast := SuiteHeritageInterface^ast;
end


}

HeritageInterface -> #ast;
#ast {
do
   HeritageInterface^ast := new LinkedList<Interface>();
end
}

SuiteHeritageInterface -> virgule identificateur_type #inh InstanceGenericite SuiteHeritageInterface #ast;
#inh{
  do
  	if (SuiteHeritageInterface^tds.contains(identificateur_type^txt)) then
  		SuiteHeritageInterface^ast.add(identificateur_type^txt);
  	else
  		error(HERITAGE_INTERFACE_INEXISTANTE, identificateur_type^txt);
  	end	
  end
}
#ast{
local
   od : Optional<Declaration>;
   d : Declaration;
do
	od := SuiteHeritageInterface^tdsNomsInterface.get(identificateur_type^txt);
	d := od.get();
	match d with Interface then
		SuiteHeritageInterface^ast.addFirst(d);
    end
	SuiteHeritageInterface^ast := SuiteHeritageInterface1^ast;
end
}

SuiteHeritageInterface -> #ast;
#ast {
do
	SuiteHeritageInterface^ast := new LinkedList<Interface>();
end 
}


ElementsInterface -> ElementInterface #tds ElementsInterface #ast ;
#tds {
do
	ElementsInterface1^tds.register(ElementInterface^ast);
end
}
#ast{
do
	ElementsInterface1^elements.addFirst(ElementInterface^ast);
	ElementsInterface^elements := ElementsInterface1^elements;
end
}


ElementsInterface -> #ast;
#ast {
do
	ElementsInterface^elements := new LinkedList<ElementInterface>();
end
}


ElementInterface -> final statique Type identificateur affectation Expression point_virgule #ast;
#ast {
local
	cd : Element;
do
	if ElementInterface^tdsConstantesInterface.contains(identificateur^txt) then
		error(CONSTANT_ALREADY_DECLARED);
	else
		cd := ElementInterface^factory.createConstantDeclaration(identificateur^txt, Type^ast, Expression^ast);
		ElementInterface^ast := cd;
		ElementInterface^tdsConstantesInterface.register(cd);
	end
end
}
	

ElementInterface -> Signature point_virgule #ast ;
#ast {
do
	ElementInterface^ast := Signature^ast;
end
}	


Signature -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante #ast;
#ast {
local
	sd : SignatureDeclaration;
do
	sd := Signature^factory.createSignature(identificateur^txt, Parametres^ast);
	Signature^ast := sd;
	Signature^tdsSignaturesInterface.registerSignature(sd);
end
}
  
 
Signature -> Type identificateur parenthese_ouvrante Parametres parenthese_fermante #ast;
#ast {
do
	Signature^ast := Signature^factory.createSignature(identificateur^txt, Type^ast, Parametres^ast);
end
}   



Classes -> Classe Classes #classes;
#classes {
local 
    classes : LinkedList<Classe>;
do
    classes := Classes1^classes;
    classes.addFirst(Classe^ast);
    Classes^classes := classes;
end
}

Classes -> #classes;
#classes {
do
   Classes^classes := new LinkedList<Classe>();
end
}


Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante #classe;
#classe {
local
   cd : ClasseDeclaration;
do
   -- Si l'identificateur de type est connu
   if Classe^tds.contains(identificateur_type^txt) then
      error(CLASSE_error,identificateur_type^txt);
   else
      cd := Classe^factory.createClasse(identificateur_type^txt, Genericite^ast, HeritageClasse^ast, ElementsClasse^ast);
      Classe^tds.register(cd);
      Classe^ast := cd;
   end
end
}


HeritageClasse -> extension identificateur_type InstanceGenericite #ast;
#ast{
  local 
    hcd : HeritageClasseDeclaration;
  do
    if HeritageClasse^tds.contains(identificateur_type^txt) then
      hcd := HeritageClasse^factory.createHeritageClasse(identificateur_type^txt, InstanceGenericite^ast);
      HeritageClasse^tds.register(hcd);
      HeritageClasse^ast:= hcd;
    else 
      error(Classe_inexistante, identificateur_type^txt);
    end
  end
}

HeritageClasse -> #ast;
#ast {
do
   HeritageClasse^ast := nil;
end
}


ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface #ast;
#ast {
do
	ImplantationInterface^ast := ImplantationInterface^factory.createImplantation (identificateur_type^txt, InstanceGenericite^ast, SuiteHeritageInterface^ast);
end
}
	

ImplantationInterface -> #ast;
#ast {
do
	ImplantationInterface^ast:=nil;
end
}


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante #ast ;
#ast {
local
	c : ClasseDeclaration;
do
	if Principale^tds.contains(identificateur_type^txt) then
		error(ERROR_CLASSEEXISTANTE, identificateur_type^txt);
	else
		c:= Principale^factory.createClassePrincipale(identificateur_type^txt, MethodePrincipale^ast);
		Principale^tds.register(c);
		Principale^ast:=c;
	end
end
} 	
		


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc #ast ;
#ast {
do
	MethodePrincipale^ast := MethodePrincipale^factory.createMethodeDeclaration ( "main", "String", identificateur^txt, Bloc^ast);
end
}



Genericite -> inferieur ParametresGenericite superieur ;

Genericite -> #ast;
#ast {
do
	Genericite^ast := Genericite^factory.newGenericDeclaration();
end
}



ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> ;


ParametreGenericite -> identificateur_type HeritageGenericite ;  
 
ParametreGenericite -> choix HeritageGenericite ;  
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> ;


ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;

ElementsClasse -> DroitAcces ElementClasse ElementsClasse #ast;
#ast {
local
   ec : ElementClasse;
do
   ec := ElementClasse^ast;
   ec.setDroit(DroitAcces^ast);
   ElementsClasse1^elements.addFirst(ec);
   ElementsClasse^elements := ElementsClasse1^elements;
end  
}

ElementsClasse -> #ast;
#ast {
do
    ElementsClasse^elements := new LinkedList<ElementClasse>();
end
}


DroitAcces -> public #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PUBLIC;
end
}  

DroitAcces -> protege #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PROTECTED;
end
}  
 
DroitAcces -> prive #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PRIVATE;
end
}


ElementClasse -> statique AttributOuMethode #ast;
#ast {
local
  ec : ElementClasse;
do
  ec := AttributOuMethode^ast;
  ec.setStatic(true);
  ElementClasse^ast := ec;
end
}

ElementClasse -> AttributOuMethode #ast;
#ast {
do
    ElementClasse^ast := AttributOuMethode^ast;
end
}
 
ElementClasse -> Constructeur #ast;
#ast {
do
    ElementClasse^ast := Constructeur^ast;
end
}  

AttributOuMethode -> Type identificateur SuiteAttributOuMethode #ast;
#ast {
do
    AttributOuMethode^ast := SuiteAttributOuMethode^ast;
    AttributOuMethode.setType(Type^ast);
    AttributOuMethode.setName(identificateur^txt);
end
}

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    AttributOuMethode^ast := AttributOuMethode^factory.createMethode(identificateur^txt, Parametres^parametres, Bloc^ast);
end
}


SuiteAttributOuMethode -> point_virgule #ast;
#ast {
do
    SuiteAttributOuMethode^ast := SuiteAttributOuMethode^factory.createProperty();
end
}

SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    SuiteAttributOuMethode^ast := SuiteAttributOuMethode^factory.createMethode(Parametres^parametres, Bloc^ast);
end
}


Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    if Constructeur^nom_classe.equals(identificateur_type^txt)
    then Constructeur^ast := Constructeur^factory.createConstructeur(identificateur_type^txt, Parametres^parametres, Bloc^ast);
    else error(CLASS_constructeur_name_does_not_match, identificateur_type^txt);
    end
end
}

Parametres -> #parametres;
#parametres {
do
  Parametres^parametres := new LinkedList<Parametre>();
end
}

Parametres -> Parametre SuiteParametres #parametres;
#parametres {
local
    parametres : LinkedList<Parametre>;
do
    parametres := SuiteParametres^parametres;
    parametres.addFirst(Parametre^parametre);
    Parametres^parametres := parametres;
end
}

Parametre -> Type identificateur #parametre;
#parametre {
local
   p : Parametre;
do
   -- Si l'identificateur est connu
   if Parametre^tds.contains(identificateur^txt) then
      error(PARAMETRE_already_defined,identificateur^txt);
   else
      p := Parametre^factory.createParameter(identificateur^txt, Type^ast);
      Parametre^tds.register(p);
      Parametre^parametre := p;
   end
end
}

SuiteParametres -> #parametres;
#parametres {
do
  SuiteParametres^parametres := new LinkedList<Parametre>();
end
}

SuiteParametres -> virgule Parametre SuiteParametres #parametres;
#parametres {
local
  parametres : LinkedList<Parametre>;
do
  parametres := SuiteParametres1^parametres;
  parametres.addFirst(Parametre^parametre);
  SuiteParametres^parametres := parametres;
end
}

Bloc -> accolade_ouvrante #inh Instructions accolade_fermante #ast ;
#inh {
do
  Instructions^tds := new SymbolTable(Bloc^tds);
end
}
#ast {
do
    Bloc^ast := Bloc^factory.createBlock(Instructions^ast);
end
}

TypeAtomique -> #inh SuiteTypeAtomique #ast;
#ast {
do
    TypeAtomique^ast := SuiteTypeAtomique^ast;
end
}
#inh {
do
    SuiteTypeAtomique^ast := TypeAtomique^ast;
end
}

TypeAtomique -> type_bool #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createBooleanType();  
end
}

TypeAtomique -> type_int  #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createIntegerType();
end
}  
 
TypeAtomique -> type_char #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createCharType();
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createStringType();
end
}
 
TypeAtomique -> identificateur_type InstanceGenericite ;


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #inh SuiteTypeAtomique #ast;
#inh {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique^factory.createArrayType(SuiteTypeAtomique^ast);
end
}
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique1^ast;
end
}

SuiteTypeAtomique -> #ast;
#ast {
do
    SuiteTypeAtomique^ast :=
end  
}


Instructions -> #ast;
#ast {
do
    Instructions^ast := new ArrayList<Instruction>();
end
}

Instructions -> Instruction Instructions #ast;
#ast {
local
    ast : ArrayList<Instruction>;
do
    ast := Instructions1^ast;
    ast.add(0, Instruction^ast);
    Instructions^ast := ast;
end
}

Instruction -> Type identificateur affectation Expression point_virgule ;

Instruction -> Expression point_virgule ;

Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle #ast;
#ast
{
do
    if (SuiteConditionnelle^ast = nil)
    then Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
    else Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast, SuiteConditionnelle^ast);
    end
end
}

SuiteConditionnelle -> #ast ;
#ast
{
do
    SuiteConditionnelle^ast := nil;
end
}

SuiteConditionnelle -> sinon Bloc #ast ;
#ast
{
do
    SuiteConditionnelle^ast := Bloc^ast;
end
}

Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}

Instruction -> afficher Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createPrinter(Expression^ast);
end
}

Instruction -> retour Expression point_virgule ;


Expression -> Affectation SuiteAffectation ;


Expression -> Condition #inh SuiteCondition #ast ;
#inh {
do
    SuiteCondition^gauche := Condition^ast ;
end
}
#ast {
do
    Expression^ast := SuiteCondition^ast;
end
}

SuiteAffectation -> affectation Expression ;

SuiteAffectation -> ;

SuiteCondition -> Comparatif Condition #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^factory.createBinaryExpression(
                              SuiteCondition^gauche,
                              Comparatif^bin_op,
                              Condition^ast);
end
}

SuiteCondition -> #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^gauche;
end
}

Comparatif -> egalite #texte;
#texte {
do
    Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Different;   
end  
}
 
Comparatif -> inferieur #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}
 
Comparatif -> inferieur_egal #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}
 
Comparatif -> superieur #texte;  
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.Greater;    
end  
}
   
Comparatif -> superieur_egal #texte;  
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}
   
Condition -> Terme #ast_inh SuiteTerme #ast_syn ;
#ast_inh {
do
   SuiteTerme^gauche := Terme^ast;
end
}
#ast_syn {
do
   Condition^ast := SuiteTerme^ast;
end
}

SuiteTerme -> Additif Terme #ast_inh SuiteTerme #ast_syn ;  
#ast_inh {
do
    SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
                              SuiteTerme^gauche,  
                              Additif^bin_op,  
                              Terme^ast);  
end

#ast_syn {
do
    SuiteTerme^ast := SuiteTerme1^ast;
end
}

SuiteTerme -> #ast ;
#ast {
do
    SuiteTerme^ast := SuiteTerme^gauche;
end
}

Additif -> addition #ast;  
#ast {
do  
    Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Substract;   
end  
}

Additif -> ou #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Or;   
end  
}

Terme -> Facteur #ast_inh SuiteFacteur #ast_syn ;
#ast_inh {
do
    SuiteFacteur^gauche := Facteur^ast;
end
}
#ast_syn {
do
    Terme^ast := SuiteFacteur^ast;
end
}

SuiteFacteur -> Multiplicatif Facteur #ast_inh SuiteFacteur #ast_syn ;  
#ast_inh {
do
    SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
                                  SuiteFacteur^gauche,  
                                  Multiplicatif^bin_op,  
                                  Facteur^ast);  
end
}
#ast_syn {
do
    SuiteFacteur^ast := SuiteFacteur1^ast;
end
}

SuiteFacteur -> #ast;  
#ast {
do
    SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast;
#ast {
do
    Multiplicatif^bin_op := BinaryOperator.Multiply;
end
}

Multiplicatif -> division #ast;
#ast {
do
    Multiplicatif^bin_op := BinaryOperator.Divide;  
end
}
 
Multiplicatif -> modulo #ast;
#ast {  
do
    Multiplicatif^bin_op := BinaryOperator.Modulo;   
end
}
 
Multiplicatif -> et #ast;
#ast {  
do
    Multiplicatif^bin_op := BinaryOperator.And;   
end
}

 
Facteur -> accolade_ouvrante Expressions accolade_fermante #ast ;
#ast {
do
    Facteur^ast := Facteur^factory.createSequence( Expressions^expressions );
end
}

Expressions -> Expression SuiteExpressions #ast ;
#ast {
do
    SuiteExpressions^expressions.addFirst(Expression^ast);
    Expressions^expressions := SuiteExpressions^expressions;
end
}

SuiteExpressions -> virgule Expression SuiteExpressions #ast ;
#ast {
do
    SuiteExpressions1^expressions.addFirst(Expression^ast);
    SuiteExpressions^expressions := SuiteExpressions1^expressions;
end
}

SuiteExpressions -> #ast ;
#ast {
do
    SuiteExpressions^expressions := new LinkedList<Expression>();
end
}

Facteur -> soustraction Facteur #ast ;  
#ast {
do  
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}
 
Facteur -> negation Facteur #ast ;  
#ast {
do  
    Facteur^ast := Facteur ^factory. createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end  
}

Facteur -> nouveau Type #inh SuiteNouveau #ast ;
#inh {
do
    SuiteNouveau^type := Type^ast;
end
}
#ast {
do
    Facteur^ast := SuiteNouveau^ast;
end
}

SuiteNouveau -> crochet_ouvrant Expression crochet_fermant #ast ;
#ast {
do  
    SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);  
end  
}

SuiteNouveau -> Arguments #ast ;
#ast {
do 
SuiteNouveau^ast := SuiteNouveau^factory.createAllocation(Arguments^ast);
end
}

Arguments -> parenthese_ouvrante parenthese_fermante #ast;
#ast {
do
    Arguments^ast := Arguments^factory.createArguments();
end
}

Arguments -> parenthese_ouvrante Expressions parenthese_fermante ;
#ast {
do
    Arguments^ast := Arguments^factory.createArguments(Expressions^ast);
end
}
 
Facteur -> Valeur #ast;
#ast {
do
    Facteur^ast := Valeur^ast;
end
}
 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt);
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

Valeur -> chaine ;
#ast {
do 
    Valeur^ast := Valeur^factory.createStringValue(chaine^txt);
end
}

Valeur -> caractere ;
#ast {
do
    Valeur^ast := Valeur^factory.createCharacterValue(caractere^txt);
end
}


Facteur -> identificateur AppelOuAcces ;


AppelOuAcces -> Acces ;

AppelOuAcces -> Appel ;


Acces -> #ast ;
#ast {
do  
    Acces^ast := Acces^support;  
end  
}

Acces -> crochet_ouvrant Expression crochet_fermant #inh Acces #ast;
#inh {
do
    Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}
#ast {
do  
    Acces^ast := Acces1^ast;  
end  
}

Acces -> point identificateur AppelOuAcces ;


Appel -> Arguments Acces ;


Facteur -> identificateur_type point identificateur AppelOuAcces ;

Facteur -> parenthese_ouvrante Expression parenthese_fermante #ast;  
#ast {
do  
    Facteur^ast := Expression^ast;  
end  
}

end
