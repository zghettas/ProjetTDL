----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh gauche      : Expression for SuiteCondition, SuiteTerme, SuiteFacteur;

inh factory     : BlockFactory for Bloc, Instruction, SuiteConditionnelle, Instructions, 
                  Expression, Expressions, SuiteExpressions, Condition, SuiteCondition, 
                  Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, TypeAtomique, Affectable, 
                  SuiteAffectable, Acces, SuiteNouveau ;  

inh tds         : SymbolTable for Bloc, Instructions, Instruction, Expression, Expressions,
                  SuiteExpressions, Facteur, SuiteConditionnelle, Terme, SuiteTerme, SuiteFacteur,
                  Condition, SuiteCondition, TypeAtomique, Valeur, Affectable, SuiteAffectable, SuiteNouveau, Acces, Interfaces, Classes, Principale;

inh tdsSignaturesInterfaces : 	SymbolTableSignature for Interfaces;

inh tdsConstantesInterfaces :  	SymbolTable for Interfaces;

inh tdsNomsInterfaces	    :	SymbolTable for Interfaces;

inh elementsClasses	    : 	SymbolTable for Classes;

inh type        : Type for SuiteTypeAtomique ;

inh support     : Expression for Acces ;

inh support     : Assignable for SuiteAffectable ;

inh type        : Type for SuiteNouveau ;

syn ast         : Block for Programme, Bloc, SuiteConditionnelle ;

syn ast         : Expression for Expression, Condition, SuiteCondition, Terme, SuiteTerme, 
                  Facteur, SuiteFacteur, Acces, SuiteNouveau ;

syn ast         : Type for TypeAtomique ;

syn ast         : Value for Valeur ;

syn ast         : ArrayList<Instruction> for Instructions ;

syn ast         : Instruction for Instruction ;

syn ast         : Assignable for Affectable, SuiteAffectable ;

syn bin_op      : BinaryOperator for Additif, Multiplicatif, Comparatif ;

syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions ;

syn interfaces  : LinkedList<InterfaceDeclaration> for Interfaces ;

syn interface   : InterfaceDeclaration for Interface ;

syn ast 	: HeritageDeclaration for HeritageInterface, SuiteHeritageInterface;

syn ast 	: Instance for InstanceGenericite;

syn ast 	: Signature for ElementInterface;

syn elements 	: LinkedList<Signature> for ElementsInterface;

syn ast 	: Implantation for ImplantationInterface;

syn ast		: Type for Type;

syn ast		: Methode for MethodePrincipale;

syn ast		: Classe for Principale;

syn classes	: LinkedList<Classe> for Classes;

syn interfaces	: LinkedList<Interface> for Interfaces;


space  separateur             is    "[\n\r\t ]+";
space  commentaire            is    "\/\/.*\n";
sugar  accolade_ouvrante      is    "\{";  
sugar  accolade_fermante      is    "\}";  
sugar  crochet_ouvrant        is    "\[";  
sugar  crochet_fermant        is    "\]";  
sugar  parenthese_ouvrante    is    "\(";
sugar  parenthese_fermante    is    "\)";
sugar  inferieur              is    "\<";  
sugar  superieur              is    "\>";  
sugar  inferieur_egal         is    "\<=";  
sugar  superieur_egal         is    "\>=";  
sugar  point                  is    "\.";  
sugar  point_virgule          is    ";";  
sugar  virgule                is    ",";
sugar  affectation            is    "=";
sugar  egalite                is    "==";  
sugar  different              is    "\!=";  
sugar  addition               is    "\+";
sugar  soustraction           is    "\-";
sugar  ou                     is    "\|\|";  
sugar  multiplication         is    "\*";
sugar  division               is    "/";
sugar  modulo                 is    "%";
sugar  adresse                is    "&";  
sugar  negation               is    "\!";  
sugar  et                     is    "&&";  
sugar  vrai                   is    "true";
sugar  faux                   is    "false";
sugar  si                     is    "if";
sugar  sinon                  is    "else";
sugar  afficher               is    "print";  
sugar  nouveau                is    "new";  
sugar  tant_que               is    "while";  
sugar  retour                 is    "return";  
sugar  type_int               is    "int";
sugar  type_bool              is    "boolean";  
sugar  type_char              is    "char";        
sugar  type_String            is    "String";        
sugar  vide                   is    "void";     
sugar  nul                    is    "null";     
sugar  choix                  is    "\?";         
sugar  deux_points            is    ":";          
sugar  interface              is    "interface";     
sugar  classe                 is    "class";      
sugar  extension              is    "extends";      
sugar  implantation           is    "implements";      
sugar  public                 is    "public";    
sugar  protege                is    "protected";    
sugar  prive                  is    "private";     
sugar  statique               is    "static";       
sugar  final                  is    "final";       
sugar  principale             is    "main";  
term   chaine                 is    "\"([^\"]|\\\")*\"";  
term   caractere              is    "\'[^\']\'";  
term   entier                 is    "[0-9]+";
term   identificateur         is    "[a-z_][a-zA-Z0-9_]*"; 
term   identificateur_type    is    "[A-Z][a-zA-Z0-9_]*"; 


Programme -> #tds Interfaces Classes Principale #ast;
#tds {
local
	st : SymbolTable;
	st2 : SymbolTable;
	st2_1 : SymbolTableSignatures;
	st2_2 : SymbolTable;
	st3 : SymbolTable;
	st3_1 : SymbolTable;
	st3_2 : SymbolTable;
	st4 : SymbolTable;
	st4_1 : SymbolTable;
	st4_2 : SymbolTable;
do
	st := new SymbolTable();
	Interfaces^tds := st;
	Classes^tds := st;
	Principale^tds := st;
	st2 := new SymbolTable();
	Interfaces^tdsNomsInterfaces := st2;
	st2_1 := new SymbolTableSignature();
	Interfaces^tdsSignaturesInterfaces := st2_1;
	st2_2 := new SymbolTable();
	Interfaces^tdsConstantesInterface := st2_2;
	st3 := new SymbolTable();
	Classes^elementsClasses := st3;
	st4 := new SymbolTable();
	Principale^elementsPrincipale := st4;
	
end
}
#ast {
local
	bfi : BlockFactoryImpl;
do
	bfi := new BlockFactoryImpl();
	Programme^ast := bfi.createProgramme(Interfaces^interfaces, Classes^classes, Principale^ast);
end
}


Interfaces -> #tds Interface #tds1 Interfaces #interfaces;
#interfaces {
local
	interfaces : LinkedList<Interfaces>;
do
    interfaces := Interfaces1^interfaces;
    interfaces.addFirst(Interface^interface);
    Interfaces^interfaces := interfaces;
end
}
#tds {
do
	Interface^tdsConstantesInterface := new SymbolTable();
	Interface^tdsSignaturesInterface := new SymbolTable();
end
}
#tds1 {
local
	bfi : BlockFactoryImpl;
do
	bfi := new BlockFactoryImpl();
	if Interfaces^tdsNomsInterfaces.contains(Interface^ast.getNom()) then
		error(INTERFACE_ALREADY_DECLARED);
	else
		Interfaces1^tdsNomsInterfaces.register(bfi.createInterfaceDeclaration(Interface^ast));
	end
end
}

Interfaces -> #interfaces;
#interfaces {
do
   Interfaces^interfaces := new LinkedList<Interface>();
end
}

Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante #inh ElementsInterface accolade_fermante #interface;
#interface {
local
   	i : Interface;
do
	i := Interface^factory.createInterface(identificateur_type^txt, Genericite^ast, HeritageInterface^ast, ElementsInterface^ast);
   	Interface^interface := i;
end
}

HeritageInterface -> extension identificateur_type InstanceGenericite SuiteHeritageInterface #ast;
#ast{
  local 
    hmd : HeritageMultipleDeclaration;
  do
    if HeritageInterface^tds.contains(identificateur_type^txt) then
      hmd := HeritageInterface^factory.createHeritageMultiple(identificateur^txt, InstanceGenericite^ast, SuiteHeritageInterface^ast);
      HeritageInterface^tds.register(hmd);
      HeritageInterface^ast:= hmd;
    else 
      error(Classe_inexistante, identificateur_type^txt);
    end
  end
}

HeritageInterface -> #ast;
#ast {
do
   HeritageInterface^ast := nil;
end
}

SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite SuiteHeritageInterface #ast;
#ast{
  local
    shi : SuiteHeritageInterface;
  do
    if SuiteHeritageInterface^tds.contains(identificateur_type^txt) then
            shi := SuiteHeritageInterface^factory.createHeritageMultiple(identificateur^txt, InstanceGenericite^ast, SuiteHeritageInterface^ast);
            SuiteHeritageInterface^tds.register(shi);
            SuiteHeritageInterface^ast := shi;
    else
      error(Classe_inexistante, identificateur_type^txt);
  end
}

SuiteHeritageInterface -> #ast;
#ast {
do
	SuiteHeritageInterface^ast := nil;
end 
}


ElementsInterface -> ElementInterface #tds ElementsInterface #ast ;
#tds {
do
	ElementsInterface1^tds.register(ElementInterface^ast);
end
}
#ast{
do
	ElementsInterface1^ast.addFirst(ElementInterface^ast);
	ElementsInterface^ast := ElementsInterface1^ast;
end
}


ElementsInterface -> #ast;
#ast {
do
	ElementsInsterface^elementsInterface := new LinkedList<ElementInterface>();
end
}


ElementInterface -> final statique Type identificateur affectation Expression point_virgule #ast;
#ast {
local
	cd : ConstantDeclaration;
do
	if ElementInterface^tdsConstantesInterface.contains(identificateur^txt) then
		error(CONSTANT_ALREADY_DECLARED);
	else
		cd := ElementInterface^factory.createConstantDeclaration(identificateur^txt, Type^ast, Expression^ast);
		ElementInterface^ast := cd;
		ElementInterface^tdsConstantesInterface.register(ElementInterface^ast);
end
}
	

ElementInterface -> Signature point_virgule #ast ;
#ast {
do
	ElementInterface^ast := Signature^ast;
end
}	


Signature -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante #ast;
#ast {
local
	sd : SignatureDeclaration;
do
	sd := Signature^factory.createSignature(identificateur^txt, Parametres^ast);
	Signature^ast := sd;
	Signature^signaturesInterface.registerSignature(Signature^ast);
end
}
  
 
Signature -> Type identificateur parenthese_ouvrante Parametres parenthese_fermante #ast;
#ast {
do
	Signature^ast := Signature^factory.createSignature(identificateur^txt, Type^ast, Parametres^ast);
end
}   



Classes -> Classe Classes #classes;
#classes {
local 
    classes : LinkedList<ClasseDeclaration>;
do
    classes := Classes^classes;
    classes.addFirst(Classe^classe);
    Classes^classes := classes;
end
}

Classes -> #classes;
#classes {
do
   Classes^classes := new LinkedList<ClasseDeclaration>();
end
}


Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante #classe;
#classe {
local
   cd : ClasseDeclaration;
do
   -- Si l'identificateur de type est connu
   if Classe^tds.contains(identificateur_type^txt) then
      error(CLASSE_error,identificateur_type^txt);
   else
      cd := Classe^factory.createClasse(identificateur_type^txt, Genericite^ast, HeritageClasse^ast, ElementsClasse^ast);
      Classe^tds.register(cd);
      Classe^classe := cd;
   end
end
}


HeritageClasse -> extension identificateur_type InstanceGenericite #ast;
#ast{
  local 
    hcd : HeritageClasseDeclaration;
  do
    if HeritageClasse^tds.contains(identificateur_type^txt) then
      hcd := HeritageClasse^factory.createHeritageClasse(identificateur^txt, InstanceGenericite^ast);
      HeritageClasse^tds.register(hcd);
      HeritageClasse^ast:= hcd;
    else 
      error(Classe_inexistante, identificateur_type^txt);
    end
  end
}

HeritageClasse -> #ast;
#ast {
do
   HeritageClasse^ast := nil;
end
}


ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface #ast;
#ast {
do
	ImplantationInterface^ast := ImplantationInterface^factory.createImplantation (identificateur_type^txt, InstanceGenericite^ast, SuiteHeritageInterface^ast);
end
}
	

ImplantationInterface -> #ast;
#ast {
do
	ImplantationInterface^ast:=nil;
end
}


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante #ast ;
#ast {
local
	c : ClasseDeclaration;
do
	if Principale^tds.contains(identificateur_type^txt) then
		error(ERROR_CLASSEEXISTANTE, identificateur_type^txt);
	else
		c:= Principale^factory.createClassePrincipale(identificateur_type^txt, MethodePrincipale^ast);
		Principale^tds.register(c);
		Principale^ast:=c;
	end
end
} 	
		


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc #ast ;
#ast {
do
	MethodePrincipale^ast := MethodePrincipale^factory.createMethodeDeclaration ( principale^txt, type_String^txt, identificateur^txt, Bloc^ast);
end
}



Genericite -> inferieur ParametresGenericite superieur ;

Genericite -> ;


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> ;


ParametreGenericite -> identificateur_type HeritageGenericite ;  
 
ParametreGenericite -> choix HeritageGenericite ;  
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> ;


ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;

ElementsClasse -> DroitAcces ElementClasse ElementsClasse #ast;
#ast {
do 
   ElementsClasse1^elements.addFirst(ElementClasse^ast);
   ElementsClasse^elements := ElementsClasse1^elements; 
   ElementClasse^droit := DroitAcces^ast;
end  
}

ElementsClasse -> #ast;
#ast {
do 
    ElementsClasse^elements := new LinkedList<ElementClasse>();
end
}


DroitAcces -> public #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PUBLIC;
end
}  

DroitAcces -> protege #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PROTECTED;
end
}  
 
DroitAcces -> prive #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PRIVATE;
end
}


ElementClasse -> statique AttributOuMethode #ast;
#ast {
local
  ec : ElementClasse;
do
  ec := AttributOuMethode^ast;
  ec.setStatic(true);
  ElementClasse^ast := ec;
end
}

ElementClasse -> AttributOuMethode #ast;
#ast {
do
    ElementClasse^ast := AttributOuMethode^ast;
end
}
 
ElementClasse -> Constructeur #ast;
#ast {
do
    ElementClasse^ast := Constructeur^ast;
end
}  

AttributOuMethode -> Type identificateur SuiteAttributOuMethode #ast;
#ast {
do
    AttributOuMethode^ast := AttributOuMethode^factory.createAttributOuMethodeDeclaration(identificateur^ast, Type^ast, SuiteAttributOuMethode^ast);
end
}

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc;
#ast {
do
    AttributOuMethode^ast := AttributOuMethode^factory.createMethodeVideDeclaration(identificateur^ast, Parametres^ast, Bloc^ast);
end
}


SuiteAttributOuMethode -> point_virgule #ast;
#ast {
do
    SuiteAttributOuMethode^ast := SuiteAttributOuMethode^factory.createProperty(SuiteAttributOuMethode^acces, SuiteAttributOuMethode^nom, SuiteAttributOuMethode^type);
end
}

SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    SuiteAttributOuMethode^ast := SuiteAttributOuMethode^factory.createMethodeDeclaration(Parametres^ast, Bloc^ast);
end
}


Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    if Constructeur^nom.equals(identificateur_type^txt)
    then Constructeur^ast := Constructeur^factory.createConstructeur(identificateur_type^txt, Parametres^ast, Bloc^ast);
    else error(CLASS_constructeur_name_does_not_match, identificateur_type^txt);
end
} 

Parametres -> #parametres;
#parametres {
do
	Parametres^parametres := new LinkedList<Parametre>();
end
}

Parametres -> Parametre SuiteParametres #parametres;
#parametres {
local 
    parametres : LinkedList<Parametre>;
do
    parametres := Parametres^parametres;
    parametres.addFirst(Parametre^parametre);
    Parametres^parametres := parametres;
end
}

Parametre -> Type identificateur #parametre;
#parametre {
local
   p : Parametre;
do
   -- Si l'identificateur est connu
   if Parametre^tds.contains(identificateur^txt) then
      error(PARAMETRE_already_defined,identificateur^txt);
   else
      p := Parametre^factory.createParameter(identificateur^txt, Type^type);
      Parametre^tds.register(p);
      Parametre^parametre := p;
   end
end
}

SuiteParametres -> #parametres;
#parametres {
do
  SuiteParametres^parametres := new LinkedList<Parametre>();
end
}

SuiteParametres -> virgule Parametre SuiteParametres #parametres;
#parametres {
local 
  parametres : LinkedList<Parametre>;
do
  parametres := SuiteParametres^parametres;
  parametres.addFirst(Parametre^parametre);
  SuiteParametres^parametres := parametres;
end
}

Bloc -> accolade_ouvrante #inh Instructions accolade_fermante #ast ;
#inh {
do 
  Instructions^tds := new SymbolTable(Bloc^tds);
end
}
#ast {
do
    Bloc^ast := Bloc^factory.createBlock(Instructions^ast);
end
}

TypeAtomique -> #inh SuiteTypeAtomique #ast;
#ast {
do
    TypeAtomique^ast := SuiteTypeAtomique^ast;
end
}
#inh {
do
    SuiteTypeAtomique^type := TypeAtomique^ast;
end 
}

TypeAtomique -> type_bool #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createBooleanType();  
end
}

TypeAtomique -> type_int  #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createIntegerType(); 
end
}  
 
TypeAtomique -> type_char #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createCharType(); 
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createStringType();
end
}
 
TypeAtomique -> identificateur_type InstanceGenericite ; 


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #inh SuiteTypeAtomique #ast;
#inh {
do
    SuiteTypeAtomique^type := SuiteTypeAtomique^factory.createArrayType(SuiteTypeAtomique^type);
end
}
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique1^ast;
end
}

SuiteTypeAtomique -> #ast;
#ast {
do
    SuiteTypeAtomique^ast := 
end  
}


Instructions -> #ast;
#ast {
do
    Instructions^ast := new ArrayList<Instruction>();
end
}

Instructions -> Instruction Instructions #ast;
#ast {
local 
    ast : ArrayList<Instruction>;
do
    ast := Instructions1^ast;
    ast.add(0, Instruction^ast);
    Instructions^ast := ast;
end
}

Instruction -> Type identificateur affectation Expression point_virgule ;

Instruction -> Expression point_virgule ;

Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle #ast;
#ast 
{ 
do
    if (SuiteConditionnelle^ast = nil)
    then Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
    else Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast, SuiteConditionnelle^ast);
    end
end
}

SuiteConditionnelle -> #ast ;
#ast 
{
do 
    SuiteConditionnelle^ast := nil;
end
}

SuiteConditionnelle -> sinon Bloc #ast ;
#ast 
{
do 
    SuiteConditionnelle^ast := Bloc^ast;
end
}

Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}

Instruction -> afficher Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createPrinter(Expression^ast);
end
}

Instruction -> retour Expression point_virgule ;


Expression -> Affectation SuiteAffectation ;


Expression -> Condition #inh SuiteCondition #ast ;
#inh {
do
    SuiteCondition^gauche := Condition^ast ;
end 
}
#ast {
do
    Expression^ast := SuiteCondition^ast;
end 
}

SuiteAffectation -> affectation Expression ;

SuiteAffectation -> ;

SuiteCondition -> Comparatif Condition #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^factory.createBinaryExpression(
                              SuiteCondition^gauche,
                              Comparatif^bin_op,
                              Condition^ast);
end 
}

SuiteCondition -> #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^gauche;
end 
}

Comparatif -> egalite #texte;
#texte {
do
    Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Different;   
end  
}
  
Comparatif -> inferieur #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}
  
Comparatif -> inferieur_egal #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}
  
Comparatif -> superieur #texte;  
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.Greater;    
end  
}
   
Comparatif -> superieur_egal #texte;  
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}
   
Condition -> Terme #ast_inh SuiteTerme #ast_syn ;
#ast_inh {
do 
   SuiteTerme^gauche := Terme^ast; 
end 
}
#ast_syn {
do
   Condition^ast := SuiteTerme^ast; 
end
}

SuiteTerme -> Additif Terme #ast_inh SuiteTerme #ast_syn ;  
#ast_inh {
do
    SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
                              SuiteTerme^gauche,  
                              Additif^bin_op,  
                              Terme^ast);  
end 

#ast_syn {
do 
    SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

SuiteTerme -> #ast ;
#ast {
do
    SuiteTerme^ast := SuiteTerme^gauche;
end
}

Additif -> addition #ast;  
#ast { 
do  
    Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Substract;   
end  
}

Additif -> ou #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Or;   
end  
}

Terme -> Facteur #ast_inh SuiteFacteur #ast_syn ;
#ast_inh {
do 
    SuiteFacteur^gauche := Facteur^ast; 
end 
}
#ast_syn {
do
    Terme^ast := SuiteFacteur^ast; 
end
}

SuiteFacteur -> Multiplicatif Facteur #ast_inh SuiteFacteur #ast_syn ;  
#ast_inh {
do 
    SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
                                  SuiteFacteur^gauche,  
                                  Multiplicatif^bin_op,  
                                  Facteur^ast);  
end 
}
#ast_syn {
do 
    SuiteFacteur^ast := SuiteFacteur1^ast; 
end 
}

SuiteFacteur -> #ast;  
#ast {
do
    SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast; 
#ast {
do 
    Multiplicatif^bin_op := BinaryOperator.Multiply; 
end 
}

Multiplicatif -> division #ast; 
#ast { 
do 
    Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
Multiplicatif -> modulo #ast; 
#ast {  
do 
    Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
Multiplicatif -> et #ast; 
#ast {  
do 
    Multiplicatif^bin_op := BinaryOperator.And;   
end 
}

  
Facteur -> accolade_ouvrante Expressions accolade_fermante #ast ;
#ast {
do
    Facteur^ast := Facteur^factory.createSequence( Expressions^expressions );
end
}

Expressions -> Expression SuiteExpressions #ast ;
#ast {
do 
    SuiteExpressions^expressions.addFirst(Expression^ast); 
    Expressions^expressions := SuiteExpressions^expressions; 
end 
}

SuiteExpressions -> virgule Expression SuiteExpressions #ast ;
#ast {
do 
    SuiteExpressions1^expressions.addFirst(Expression^ast); 
    SuiteExpressions^expressions := SuiteExpressions1^expressions; 
end 
}

SuiteExpressions -> #ast ;
#ast {
do
    SuiteExpressions^expressions := new LinkedList<Expression>();
end
}

Facteur -> soustraction Facteur #ast ;  
#ast { 
do  
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}
 
Facteur -> negation Facteur #ast ;  
#ast { 
do  
    Facteur^ast := Facteur ^factory. createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end  
}

Facteur -> nouveau Type #inh SuiteNouveau #ast ; 
#inh {
do 
    SuiteNouveau^type := Type^ast; 
end 
}
#ast {
do 
    Facteur^ast := SuiteNouveau^ast; 
end 
}

SuiteNouveau -> crochet_ouvrant Expression crochet_fermant #ast ; 
#ast {
do  
    SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);  
end  
}

SuiteNouveau -> Arguments ;  


Arguments -> parenthese_ouvrante parenthese_fermante ; 

Arguments -> parenthese_ouvrante Expressions parenthese_fermante ; 

 
Facteur -> Valeur #ast;
#ast {
do
    Facteur^ast := Valeur^ast;
end
}
 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt); 
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

Valeur -> chaine ;

Valeur -> caractere ;


Facteur -> identificateur AppelOuAcces ;


AppelOuAcces -> Acces ;

AppelOuAcces -> Appel ;


Acces -> #ast ;
#ast { 
do  
    Acces^ast := Acces^support;  
end  
}

Acces -> crochet_ouvrant Expression crochet_fermant #inh Acces #ast;
#inh {
do
    Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}
#ast { 
do  
    Acces^ast := Acces1^ast;  
end  
}

Acces -> point identificateur AppelOuAcces ;


Appel -> Arguments Acces ;


Facteur -> identificateur_type point identificateur AppelOuAcces ;

Facteur -> parenthese_ouvrante Expression parenthese_fermante #ast;  
#ast { 
do  
    Facteur^ast := Expression^ast;  
end  
}

end
