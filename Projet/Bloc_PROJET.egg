----------------------------------------------- -*- text -*-
-- Langage MiniJava : Sous-ensemble du langage Java pour le projet STL 2016-2017
-- Sémantique : Construction de l'arbre abstrait
--                      Gestion de la table des symboles
--                      Typage
--                      Calcul des déplacements (Allocation mémoire)
--                      Génération de code TAM
-----------------------------------------------
option auto= true;
option version = 0.0.1 ;
option k=2;

inh gauche      : Expression for SuiteCondition, SuiteTerme, SuiteFacteur;

inh factory     : BlockFactory for Bloc, Instruction, SuiteConditionnelle, Instructions,
                  Expression, Expressions, SuiteExpressions, Condition, SuiteCondition,
                  Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur, TypeAtomique, Affectable,
                  SuiteAffectable, Acces, SuiteNouveau, AttributOuMethode, Classes, Classe, HeritageClasse, ImplantationInterface, Principale, MethodePrincipale, ElementsClasse, ElementClasse, DroitAcces, SuiteAttributOuMethode, Constructeur, Parametre, Parametres, SuiteParametres, SuiteTypeAtomique  ;  

inh tds         : SymbolTable for Bloc, Instructions, Instruction, Expression, Expressions,
                  SuiteExpressions, Facteur, SuiteConditionnelle, Terme, SuiteTerme, AttributOuMethode, SuiteAttributOuMethode, SuiteFacteur, ElementsClasse, ElementClasse,
                  Condition, SuiteCondition, TypeAtomique, Valeur, Affectable, SuiteAffectable, SuiteNouveau, Acces, Constructeur, Parametres, Parametre, SuiteParametres ;

inh type        : Type for SuiteTypeAtomique ;

inh nom_classe  : String for Classe, ElementsClasse, ElementClasse, Constructeur ;

inh support     : Expression for Acces ;

inh support     : Assignable for SuiteAffectable ;

inh type        : Type for SuiteNouveau ;

syn ast         : Block for Programme, Bloc, SuiteConditionnelle ;

syn ast         : Expression for Expression, Condition, SuiteCondition, Terme, SuiteTerme,
                  Facteur, SuiteFacteur, Acces, SuiteNouveau ;

syn ast         : Value for Valeur ;

syn ast         : ArrayList<Instruction> for Instructions ;

syn ast         : Instruction for Instruction ;

syn ast         : Assignable for Affectable, SuiteAffectable ;

syn bin_op      : BinaryOperator for Additif, Multiplicatif, Comparatif ;

syn expressions : LinkedList<Expression> for Expressions, SuiteExpressions ;

syn interfaces  : LinkedList<InterfaceDeclaration> for Interfaces ;

syn interface   : InterfaceDeclaration for Interface ;

syn ast     : HeritageDeclaration for HeritageInterface, SuiteHeritageInterface;

syn ast     : Signature for ElementInterface;

syn elements     : LinkedList<Signature> for ElementsInterface;

syn ast     : Implantation for ImplantationInterface;

syn ast        : Type for Type;

syn ast        : Methode for MethodePrincipale;

syn ast        : Classe for Principale;

syn ast      : DroitAcces for DroitAcces;

syn ast             : ElementClasse for ElementClasse,  Constructeur, AttributOuMethode, SuiteAttributOuMethode;

syn ast      : TypeAtomique for TypeAtomique, SuiteTypeAtomique

syn classes    : LinkedList<Classe> for Classes;

syn interfaces    : LinkedList<Interface> for Interfaces;

syn elements : LinkedList<ElementClasse> for ElementsClasse;

syn parametres : LinkedList<Parametre> for Parametres, SuiteParametres;

syn parametre : Parametre for Parametre;

space  separateur             is    "[\n\r\t ]+";
space  commentaire            is    "\/\/.*\n";
sugar  accolade_ouvrante      is    "\{";  
sugar  accolade_fermante      is    "\}";  
sugar  crochet_ouvrant        is    "\[";  
sugar  crochet_fermant        is    "\]";  
sugar  parenthese_ouvrante    is    "\(";
sugar  parenthese_fermante    is    "\)";
sugar  inferieur              is    "\<";  
sugar  superieur              is    "\>";  
sugar  inferieur_egal         is    "\<=";  
sugar  superieur_egal         is    "\>=";  
sugar  point                  is    "\.";  
sugar  point_virgule          is    ";";  
sugar  virgule                is    ",";
sugar  affectation            is    "=";
sugar  egalite                is    "==";  
sugar  different              is    "\!=";  
sugar  addition               is    "\+";
sugar  soustraction           is    "\-";
sugar  ou                     is    "\|\|";  
sugar  multiplication         is    "\*";
sugar  division               is    "/";
sugar  modulo                 is    "%";
sugar  adresse                is    "&";  
sugar  negation               is    "\!";  
sugar  et                     is    "&&";  
sugar  vrai                   is    "true";
sugar  faux                   is    "false";
sugar  si                     is    "if";
sugar  sinon                  is    "else";
sugar  afficher               is    "print";  
sugar  nouveau                is    "new";  
sugar  tant_que               is    "while";  
sugar  retour                 is    "return";  
sugar  type_int               is    "int";
sugar  type_bool              is    "boolean";  
sugar  type_char              is    "char";        
sugar  type_String            is    "String";        
sugar  vide                   is    "void";     
sugar  nul                    is    "null";     
sugar  choix                  is    "\?";         
sugar  deux_points            is    ":";          
sugar  interface              is    "interface";     
sugar  classe                 is    "class";      
sugar  extension              is    "extends";      
sugar  implantation           is    "implements";      
sugar  public                 is    "public";    
sugar  protege                is    "protected";    
sugar  prive                  is    "private";     
sugar  statique               is    "static";       
sugar  final                  is    "final";       
sugar  principale             is    "main";  
term   chaine                 is    "\"([^\"]|\\\")*\"";  
term   caractere              is    "\'[^\']\'";  
term   entier                 is    "[0-9]+";
term   identificateur         is    "[a-z_][a-zA-Z0-9_]*";
term   identificateur_type    is    "[A-Z][a-zA-Z0-9_]*";


Programme -> #tds Interfaces Classes Principale #ast;
#tds {
local
    st : SymbolTable;
    st2 : SymbolTable;
    st2_1 : SymbolTableSignatures;
    st2_2 : SymbolTable;
    st3 : SymbolTable;
    st3_1 : SymbolTable;
    st3_2 : SymbolTable;
    st4 : SymbolTable;
    st4_1 : SymbolTable;
    st4_2 : SymbolTable;
do
    st := new SymbolTable();
    Interfaces^tds := st;
    Classes^tds := st;
    Principale^tds := st;
    st2 := new SymbolTable();
    Interfaces^tdsNomsInterfaces := st2;
    st2_1 := new SymbolTableSignature();
    Interfaces^tdsSignaturesInterfaces := st2_1;
    st2_2 := new SymbolTable();
    Interfaces^tdsConstantesInterface := st2_2;
    st3 := new SymbolTable();
    Classes^elementsClasses := st3;
    st4 := new SymbolTable();
    Principale^elementsPrincipale := st4;
    
end
}
#ast {
local
    bfi : BlockFactoryImpl;
do
    bfi := new BlockFactoryImpl();
    Programme^ast := bfi.createProgramme(Interfaces^interfaces, Classes^classes, Principale^ast);
end
}


Interfaces -> #tds Interface Interfaces #interfaces;
#interfaces {
local
    interfaces : LinkedList<Interface>;
do
    interfaces := Interfaces1^interfaces;
    interfaces.addFirst(Interface^interface);
    Interfaces^interfaces := interfaces;
end
}
#tds {
do
    Interface^tdsConstantesInterface := new SymbolTable();
    Interface^tdsSignaturesInterface := new SymbolTable();
end
}

Interfaces -> #interfaces;
#interfaces {
do
   Interfaces^interfaces := new LinkedList<Interface>();
end
}

Interface -> interface identificateur_type Genericite HeritageInterface accolade_ouvrante  ElementsInterface accolade_fermante #interface;
#interface {
local
       i : Interface;
do
    if Interface^tdsNomsInterfaces.knows(identificateur_type^txt) then
        error(INTERFACE_ALREADY_DECLARED, identificateur_type^txt);
    else
    i := Interface^factory.createInterface(identificateur_type^txt, Genericite^ast, HeritageInterface^ast, ElementsInterface^ast);
       Interface^interface := i;
    Interface^tdsNomsInterface.register(Interface^interface);
end
}

HeritageInterface -> extension identificateur_type InstanceGenericite #tds;
#tds {
 local
    l : List<String>;
 do
     if (HeritageInterface^tdsNomsInterfaces.contains(identificateur_type^txt)) then
         l := new LinkedList<String>();
         l.add(identificateur_type^txt);
         SuiteHeritageInterface^listeHeritage := l;
     else
         error(HERITAGE_INTERFACE_INEXISTANTE, identificateur_type^txt);
     end    
 end
}
#ast{
local
   od : Optional<Declaration>;
   d : Declaration;
do
    od := HeritageInterface^tdsInterface.get(identificateur_type^txt);
    d := od.get();
    match d with Interface then
        SuiteHeritageInterface^ast.addFirst(d);
    end
    HeritageInterface^ast := SuiteHeritageInterface^ast;
end
}


HeritageInterface -> #ast;
#ast {
do
   HeritageInterface^ast := new LinkedList<Interface>();
end
}

SuiteHeritageInterface -> virgule identificateur_type InstanceGenericite SuiteHeritageInterface #ast;
#tds{
  do
      if (SuiteHeritageInterface^tdsNomsInterfaces.contains(identificateur_type^txt)) then
          SuiteHeritageInterface^listeHeritage.add(identificateur_type^txt);
          SuiteHeritageInterface1^listeHeritage := SuiteHeritageInterface^listeHeritage;
      else
          error(HERITAGE_INTERFACE_INEXISTANTE, identificateur_type^txt);
      end    
  end
}
#ast{
local
   od : Optional<Declaration>;
   d : Declaration;
do
    od := HeritageInterface^tdsInterface.get(identificateur_type^txt);
    d := od.get();
    match d with Interface then
        SuiteHeritageInterface^ast.addFirst(d);
    end
    HeritageInterface^ast := SuiteHeritageInterface^ast;
end
}


SuiteHeritageInterface -> #ast;
#ast {
do
    SuiteHeritageInterface^ast := new LinkedList<Interface>();
end 
}



ElementsInterface -> ElementInterface ElementsInterface #ast ;
#ast{
do
    ElementsInterface1^ast.addFirst(ElementInterface^ast);
    ElementsInterface^ast := ElementsInterface1^ast;
end
}


ElementsInterface -> #ast;
#ast {
do
    ElementsInsterface^elementsInterface := new LinkedList<ElementInterface>();
end
}


ElementInterface -> final statique Type identificateur affectation Expression point_virgule #ast;
#ast {
local
    cd : ConstantDeclaration;
do
    if ElementInterface^tdsConstantesInterface.contains(identificateur^txt) then
        error(CONSTANT_ALREADY_DECLARED, identificateur^txt);
    else
        cd := ElementInterface^factory.createConstantDeclaration(identificateur^txt, Type^ast, Expression^ast);
        ElementInterface^ast := cd;
        ElementInterface^tdsConstantesInterface.register(ElementInterface^ast);
end
}
    

ElementInterface -> Signature point_virgule #ast ;
#ast {
do
    ElementInterface^ast := Signature^ast;
end
}    


Signature -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante #ast;
#ast {
local
    sd : SignatureDeclaration;
    bool : Boolean;
do
    if (Signature^signaturesInterface.registerSignature(Signature^ast)) == true then
        sd := Signature^factory.createSignature(identificateur^txt, Parametres^parametres);
        Signature^ast := sd;
    else
    error(SIGNATURE_ALREADY_DECLARED, identificateur^txt);
    end   
end
}
 
 
Signature -> Type identificateur parenthese_ouvrante Parametres parenthese_fermante #ast;
#ast {
do
    Signature^ast := Signature^factory.createSignature(identificateur^txt, Type^ast, Parametres^parametres);
end
}   



Classes -> #tds Classe #tds1 Classes #classes;
#classes {
local
    classes : LinkedList<Classe>;
do
    classes := Classes1^classes;
    classes.addFirst(Classe^classe);
    Classes^classes := classes;
end
}
#tds {
do
    Classe^tdsAttributsClasse := new SymbolTable();
    Classe^tdsMethodesClasse := new SymbolTable();
end
}


Classes -> #classes;
#classes {
do
   Classes^classes := new LinkedList<ClasseDeclaration>();
end
}


Classe -> classe  identificateur_type Genericite HeritageClasse ImplantationInterface accolade_ouvrante ElementsClasse accolade_fermante #classe;
#classe {
local
   cd : ClasseDeclaration;
do
   if Classe^tdsNomsClasses.contains(identificateur_type^txt) then
      error(CLASSE_ALREADY_DECLARED, identificateur_type^txt);
   else
      cd := Classe^factory.createClasse(identificateur_type^txt, Genericite^ast, HeritageClasse^ast, ElementsClasse^ast);
      Classe^tdsNomsClasses.register(cd);
      Classe^classe := cd;
   end
end
}


HeritageClasse -> extension identificateur_type InstanceGenericite #ast;
#ast{
  local
    hcd : HeritageClasseDeclaration;
  do
    if HeritageClasse^tds.contains(identificateur_type^txt) then
      hcd := HeritageClasse^factory.createHeritageClasse(identificateur^txt, InstanceGenericite^ast);
      HeritageClasse^tds.register(hcd);
      HeritageClasse^ast:= hcd;
    else
      error(Classe_inexistante, identificateur_type^txt);
    end
  end
}

HeritageClasse -> #ast;
#ast {
do
   HeritageClasse^ast := nil;
end
}


ImplantationInterface -> implantation identificateur_type InstanceGenericite SuiteHeritageInterface #ast;
#ast {
do
    ImplantationInterface^ast := ImplantationInterface^factory.createImplantation (identificateur_type^txt, InstanceGenericite^ast, SuiteHeritageInterface^ast);
end
}
    

ImplantationInterface -> #ast;
#ast {
do
    ImplantationInterface^ast:=nil;
end
}


Principale -> public classe identificateur_type accolade_ouvrante MethodePrincipale accolade_fermante #ast ;
#ast {
local
    c : ClasseDeclaration;
do
    if Principale^tds.contains(identificateur_type^txt) then
        error(ERROR_CLASSEEXISTANTE, identificateur_type^txt);
    else
        c:= Principale^factory.createClassePrincipale(identificateur_type^txt, MethodePrincipale^ast);
        Principale^tds.register(c);
        Principale^ast:=c;
    end
end
}     
        


MethodePrincipale -> public statique vide principale parenthese_ouvrante type_String crochet_ouvrant crochet_fermant identificateur parenthese_fermante Bloc #ast ;
#ast {
do
    MethodePrincipale^ast := MethodePrincipale^factory.createMethodeDeclaration ( principale^txt, type_String^txt, identificateur^txt, Bloc^ast);
end
}



Genericite -> inferieur ParametresGenericite superieur ;

Genericite -> ;


ParametresGenericite -> ParametreGenericite SuiteParametresGenericite ;


SuiteParametresGenericite -> virgule ParametreGenericite SuiteParametresGenericite ;

SuiteParametresGenericite -> ;


ParametreGenericite -> identificateur_type HeritageGenericite ;  
 
ParametreGenericite -> choix HeritageGenericite ;  
 

HeritageGenericite -> extension identificateur_type SuiteHeritageGenericite ;

HeritageGenericite -> ;

SuiteHeritageGenericite -> adresse identificateur_type SuiteHeritageGenericite ;

SuiteHeritageGenericite -> ;


InstanceGenericite -> ;

InstanceGenericite -> inferieur ArgumentsGenericite superieur ;


ArgumentsGenericite -> ArgumentGenericite SuiteArgumentsGenericite ;


SuiteArgumentsGenericite -> virgule ArgumentGenericite SuiteArgumentsGenericite ;

SuiteArgumentsGenericite -> ;


ArgumentGenericite -> identificateur_type InstanceGenericite ;

ArgumentGenericite -> type_String ;

ElementsClasse -> DroitAcces ElementClasse ElementsClasse #ast;
#ast {
local
   ec : ElementClasse;
do
   ec := ElementClasse^ast;
   ec.setDroit(DroitAcces^ast);
   ElementsClasse1^elements.addFirst(ec);
   ElementsClasse^elements := ElementsClasse1^elements;
end  
}

ElementsClasse -> #ast;
#ast {
do
    ElementsClasse^elements := new LinkedList<ElementClasse>();
end
}


DroitAcces -> public #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PUBLIC;
end
}  

DroitAcces -> protege #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PROTECTED;
end
}  
 
DroitAcces -> prive #ast;
#ast {
do
    DroitAcces^ast := DroitAcces.PRIVATE;
end
}


ElementClasse -> statique AttributOuMethode #ast;
#ast {
local
  ec : ElementClasse;
do
  ec := AttributOuMethode^ast;
  ec.setStatic(true);
  ElementClasse^ast := ec;
end
}

ElementClasse -> AttributOuMethode #ast;
#ast {
do
    ElementClasse^ast := AttributOuMethode^ast;
end
}
 
ElementClasse -> Constructeur #ast;
#ast {
do
    ElementClasse^ast := Constructeur^ast;
end
}  

AttributOuMethode -> Type identificateur SuiteAttributOuMethode #ast;
#ast {
do
    AttributOuMethode^ast := SuiteAttributOuMethode^ast;
    AttributOuMethode.setType(Type^ast);
    AttributOuMethode.setName(identificateur^txt);
end
}

AttributOuMethode -> vide identificateur parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    AttributOuMethode^ast := AttributOuMethode^factory.createMethode(identificateur^txt, Parametres^parametres, Bloc^ast);
end
}


SuiteAttributOuMethode -> point_virgule #ast;
#ast {
do
    SuiteAttributOuMethode^ast := SuiteAttributOuMethode^factory.createProperty();
end
}

SuiteAttributOuMethode -> parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    SuiteAttributOuMethode^ast := SuiteAttributOuMethode^factory.createMethode(Parametres^parametres, Bloc^ast);
end
}


Constructeur -> identificateur_type parenthese_ouvrante Parametres parenthese_fermante Bloc #ast;
#ast {
do
    if Constructeur^nom_classe.equals(identificateur_type^txt)
    then Constructeur^ast := Constructeur^factory.createConstructeur(identificateur_type^txt, Parametres^parametres, Bloc^ast);
    else error(CLASS_constructeur_name_does_not_match, identificateur_type^txt);
    end
end
}

Parametres -> #parametres;
#parametres {
do
  Parametres^parametres := new LinkedList<Parametre>();
end
}

Parametres -> Parametre SuiteParametres #parametres;
#parametres {
local
    parametres : LinkedList<Parametre>;
do
    parametres := SuiteParametres^parametres;
    parametres.addFirst(Parametre^parametre);
    Parametres^parametres := parametres;
end
}

Parametre -> Type identificateur #parametre;
#parametre {
local
   p : Parametre;
do
   -- Si l'identificateur est connu
   if Parametre^tds.contains(identificateur^txt) then
      error(PARAMETRE_already_defined,identificateur^txt);
   else
      p := Parametre^factory.createParameter(identificateur^txt, Type^ast);
      Parametre^tds.register(p);
      Parametre^parametre := p;
   end
end
}

SuiteParametres -> #parametres;
#parametres {
do
  SuiteParametres^parametres := new LinkedList<Parametre>();
end
}

SuiteParametres -> virgule Parametre SuiteParametres #parametres;
#parametres {
local
  parametres : LinkedList<Parametre>;
do
  parametres := SuiteParametres1^parametres;
  parametres.addFirst(Parametre^parametre);
  SuiteParametres^parametres := parametres;
end
}

Bloc -> accolade_ouvrante #inh Instructions accolade_fermante #ast ;
#inh {
do
  Instructions^tds := new SymbolTable(Bloc^tds);
end
}
#ast {
do
    Bloc^ast := Bloc^factory.createBlock(Instructions^ast);
end
}

TypeAtomique -> #inh SuiteTypeAtomique #ast;
#ast {
do
    TypeAtomique^ast := SuiteTypeAtomique^ast;
end
}
#inh {
do
    SuiteTypeAtomique^ast := TypeAtomique^ast;
end
}

TypeAtomique -> type_bool #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createBooleanType();  
end
}

TypeAtomique -> type_int  #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createIntegerType();
end
}  
 
TypeAtomique -> type_char #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createCharType();
end
}

TypeAtomique -> type_String #ast ;
#ast {
do
    TypeAtomique^ast := TypeAtomique^factory.createStringType();
end
}
 
TypeAtomique -> identificateur_type InstanceGenericite ;


SuiteTypeAtomique -> crochet_ouvrant crochet_fermant #inh SuiteTypeAtomique #ast;
#inh {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique^factory.createArrayType(SuiteTypeAtomique^ast);
end
}
#ast {
do
    SuiteTypeAtomique^ast := SuiteTypeAtomique1^ast;
end
}

SuiteTypeAtomique -> #ast;
#ast {
do
    SuiteTypeAtomique^ast :=
end  
}


Instructions -> #ast;
#ast {
do
    Instructions^ast := new ArrayList<Instruction>();
end
}

Instructions -> Instruction Instructions #ast;
#ast {
local
    ast : ArrayList<Instruction>;
do
    ast := Instructions1^ast;
    ast.add(0, Instruction^ast);
    Instructions^ast := ast;
end
}

Instruction -> Type identificateur affectation Expression point_virgule ;

Instruction -> Expression point_virgule ;

Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle #ast;
#ast
{
do
    if (SuiteConditionnelle^ast = nil)
    then Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
    else Instruction^ast := Instruction^factory.createConditional(Expression^ast, Bloc^ast, SuiteConditionnelle^ast);
    end
end
}

SuiteConditionnelle -> #ast ;
#ast
{
do
    SuiteConditionnelle^ast := nil;
end
}

SuiteConditionnelle -> sinon Bloc #ast ;
#ast
{
do
    SuiteConditionnelle^ast := Bloc^ast;
end
}

Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
end
}

Instruction -> afficher Expression point_virgule #ast;
#ast {
do
    Instruction^ast := Instruction^factory.createPrinter(Expression^ast);
end
}

Instruction -> retour Expression point_virgule ;


Expression -> Affectation SuiteAffectation ;


Expression -> Condition #inh SuiteCondition #ast ;
#inh {
do
    SuiteCondition^gauche := Condition^ast ;
end
}
#ast {
do
    Expression^ast := SuiteCondition^ast;
end
}

SuiteAffectation -> affectation Expression ;

SuiteAffectation -> ;

SuiteCondition -> Comparatif Condition #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^factory.createBinaryExpression(
                              SuiteCondition^gauche,
                              Comparatif^bin_op,
                              Condition^ast);
end
}

SuiteCondition -> #ast ;
#ast {
do
    SuiteCondition^ast := SuiteCondition^gauche;
end
}

Comparatif -> egalite #texte;
#texte {
do
    Comparatif^bin_op := BinaryOperator.Equals;
end
}

Comparatif -> different #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Different;   
end  
}
 
Comparatif -> inferieur #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}
 
Comparatif -> inferieur_egal #texte;  
#texte {  
do  
    Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}
 
Comparatif -> superieur #texte;  
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.Greater;    
end  
}
   
Comparatif -> superieur_egal #texte;  
#texte {   
do  
    Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}
   
Condition -> Terme #ast_inh SuiteTerme #ast_syn ;
#ast_inh {
do
   SuiteTerme^gauche := Terme^ast;
end
}
#ast_syn {
do
   Condition^ast := SuiteTerme^ast;
end
}

SuiteTerme -> Additif Terme #ast_inh SuiteTerme #ast_syn ;  
#ast_inh {
do
    SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
                              SuiteTerme^gauche,  
                              Additif^bin_op,  
                              Terme^ast);  
end

#ast_syn {
do
    SuiteTerme^ast := SuiteTerme1^ast;
end
}

SuiteTerme -> #ast ;
#ast {
do
    SuiteTerme^ast := SuiteTerme^gauche;
end
}

Additif -> addition #ast;  
#ast {
do  
    Additif^bin_op := BinaryOperator.Add;  
end  
}

Additif -> soustraction #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Substract;   
end  
}

Additif -> ou #ast;  
#ast {  
do  
    Additif^bin_op := BinaryOperator.Or;   
end  
}

Terme -> Facteur #ast_inh SuiteFacteur #ast_syn ;
#ast_inh {
do
    SuiteFacteur^gauche := Facteur^ast;
end
}
#ast_syn {
do
    Terme^ast := SuiteFacteur^ast;
end
}

SuiteFacteur -> Multiplicatif Facteur #ast_inh SuiteFacteur #ast_syn ;  
#ast_inh {
do
    SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
                                  SuiteFacteur^gauche,  
                                  Multiplicatif^bin_op,  
                                  Facteur^ast);  
end
}
#ast_syn {
do
    SuiteFacteur^ast := SuiteFacteur1^ast;
end
}

SuiteFacteur -> #ast;  
#ast {
do
    SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

Multiplicatif -> multiplication #ast;
#ast {
do
    Multiplicatif^bin_op := BinaryOperator.Multiply;
end
}

Multiplicatif -> division #ast;
#ast {
do
    Multiplicatif^bin_op := BinaryOperator.Divide;  
end
}
 
Multiplicatif -> modulo #ast;
#ast {  
do
    Multiplicatif^bin_op := BinaryOperator.Modulo;   
end
}
 
Multiplicatif -> et #ast;
#ast {  
do
    Multiplicatif^bin_op := BinaryOperator.And;   
end
}

 
Facteur -> accolade_ouvrante Expressions accolade_fermante #ast ;
#ast {
do
    Facteur^ast := Facteur^factory.createSequence( Expressions^expressions );
end
}

Expressions -> Expression SuiteExpressions #ast ;
#ast {
do
    SuiteExpressions^expressions.addFirst(Expression^ast);
    Expressions^expressions := SuiteExpressions^expressions;
end
}

SuiteExpressions -> virgule Expression SuiteExpressions #ast ;
#ast {
do
    SuiteExpressions1^expressions.addFirst(Expression^ast);
    SuiteExpressions^expressions := SuiteExpressions1^expressions;
end
}

SuiteExpressions -> #ast ;
#ast {
do
    SuiteExpressions^expressions := new LinkedList<Expression>();
end
}

Facteur -> soustraction Facteur #ast ;  
#ast {
do  
    Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}
 
Facteur -> negation Facteur #ast ;  
#ast {
do  
    Facteur^ast := Facteur ^factory. createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end  
}

Facteur -> nouveau Type #inh SuiteNouveau #ast ;
#inh {
do
    SuiteNouveau^type := Type^ast;
end
}
#ast {
do
    Facteur^ast := SuiteNouveau^ast;
end
}

SuiteNouveau -> crochet_ouvrant Expression crochet_fermant #ast ;
#ast {
do  
    SuiteNouveau^ast := SuiteNouveau^factory.createArrayAllocation(SuiteNouveau^type,Expression^ast);  
end  
}

SuiteNouveau -> Arguments #ast ;
#ast {
do 
SuiteNouveau^ast := SuiteNouveau^factory.createAllocation(Arguments^ast);
end
}

Arguments -> parenthese_ouvrante parenthese_fermante #ast;
#ast {
do
    Arguments^ast := Arguments^factory.createArguments();
end
}

Arguments -> parenthese_ouvrante Expressions parenthese_fermante ;
#ast {
do
    Arguments^ast := Arguments^factory.createArguments(Expressions^ast);
end
}
 
Facteur -> Valeur #ast;
#ast {
do
    Facteur^ast := Valeur^ast;
end
}
 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt);
end
}

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}

Valeur -> chaine ;
#ast {
do 
    Valeur^ast := Valeur^factory.createStringValue(chaine^txt);
end
}

Valeur -> caractere ;
#ast {
do
    Valeur^ast := Valeur^factory.createCharacterValue(caractere^txt);
end
}


Facteur -> identificateur AppelOuAcces ;


AppelOuAcces -> Acces ;

AppelOuAcces -> Appel ;


Acces -> #ast ;
#ast {
do  
    Acces^ast := Acces^support;  
end  
}

Acces -> crochet_ouvrant Expression crochet_fermant #inh Acces #ast;
#inh {
do
    Acces1^support := Acces^factory.createArrayAccess(Acces^support,Expression^ast);
end
}
#ast {
do  
    Acces^ast := Acces1^ast;  
end  
}

Acces -> point identificateur AppelOuAcces ;


Appel -> Arguments Acces ;


Facteur -> identificateur_type point identificateur AppelOuAcces ;

Facteur -> parenthese_ouvrante Expression parenthese_fermante #ast;  
#ast {
do  
    Facteur^ast := Expression^ast;  
end  
}

end
